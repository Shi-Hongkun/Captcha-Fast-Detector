# Captcha Fast Detector

A fast and pragmatic captcha project. Currently, we focus on ROI calibration, character segmentation, template-based recognition, and evaluation for captcha images with consistent layout.

## Features

- ROI Calibrator: learn a fixed ROI from 25 images or txt files (no ML)
- Character Segmentation: extract 5 individual characters from ROI-cropped images
- Dataset Organization: map segmented characters to ground truth labels
- Template Builder: generate character templates from labeled dataset
- Character Recognition: template matching using NCC and MAE algorithms
- Evaluation Framework: leave-one-captcha-out validation with detailed metrics
- Main Controller: orchestrate complete pipeline from ROI to evaluation
- Export/import ROI as JSON for reuse
- Apply ROI to crop single images or entire folders
- Support for paired jpg+txt file processing
- Flexible input formats (images or txt files)

## Installation

This project uses [uv](https://github.com/astral-sh/uv) for fast Python package management and virtual environment handling.

### Prerequisites

Install uv if you haven't already:
```bash
pip install uv
```

### Setup

1. Clone the repository:
```bash
git clone <repository-url>
cd Captcha-Fast-Detector
```

2. Create and activate virtual environment with uv:
```bash
uv venv
uv sync
```

3. Activate the virtual environment:
```bash
# On Windows
.venv\Scripts\activate

# On macOS/Linux
source .venv/bin/activate
```

## Usage

### CLI Commands

1) Calibrate ROI from training images:
```bash
python -m captcha_detector calibrate -i data/input -r artifacts/roi/roi.json
```

2) Calibrate ROI from txt files:
```bash
python -m captcha_detector calibrate -i data/input --use-txt -r artifacts/roi/roi.json
```

3) Apply ROI to a single image:
```bash
python -m captcha_detector apply -r artifacts/roi/roi.json -i data/input/input00.jpg -o data/input_cropped/input00.jpg
```

4) Apply ROI to paired jpg+txt files:
```bash
python -m captcha_detector apply-paired -r artifacts/roi/roi.json -i input00.jpg -t input00.txt -o output00.jpg -u output00.txt
```

5) Batch-apply ROI to images:
```bash
python -m captcha_detector batch -r artifacts/roi/roi.json -i data/input -o data/input_cropped
```

6) Batch-apply ROI to paired files:
```bash
python -m captcha_detector batch -r artifacts/roi/roi.json -i data/input -o data/input_cropped_img_n_txt --paired
```

7) Segment characters from ROI-cropped files:
```bash
python -m captcha_detector segment -i data/input_cropped -o data/input_segmented
```

## Project Structure

```
Captcha-Fast-Detector/
├── captcha_detector/
│   ├── __init__.py
│   ├── __main__.py          # CLI for ROI calibration and character segmentation
│   ├── roi_calibrator.py    # Core ROI calibration logic
│   ├── character_segmenter.py  # Character segmentation module
│   ├── dataset_organizer.py    # Dataset organization module
│   ├── template_builder.py     # Template building module
│   ├── character_recognizer.py # Character recognition module
│   ├── evaluation.py           # Evaluation framework
│   └── captcha_detector.py     # Main controller
├── data/
│   ├── input/               # Client-provided raw images (immutable)
│   ├── output/              # Client-provided ground-truth labels
│   ├── input_cropped/       # Cropped images using the learned ROI
│   ├── input_cropped_img_n_txt/  # Cropped paired files (jpg+txt)
│   ├── input_segmented/     # Individual character segments
│   └── char_dataset/        # Labeled character dataset
├── artifacts/
│   ├── roi/
│   │   └── roi.json         # Persisted ROI bounds (small metadata)
│   ├── templates/            # Character templates and metadata
│   └── evaluation/           # Evaluation results and metrics
├── tests/                   # Test suite for all modules
├── pyproject.toml
└── README.md
```

## Development

### Testing

Run the test suite:
```bash
uv run python -m pytest
```

### Code Formatting (optional)

```bash
uv run black .
```

## Method Overview

Given 25 images generated by the same captcha generator, borders are highly consistent while text varies. We:
1. Resize images to a common size (default 60×30)
2. Stack them and compute per-pixel standard deviation
3. Use Otsu threshold on the std-map to find the dynamic region (text)
4. Derive the tight bounding box, with a small safety padding
5. Persist the ROI as JSON and reuse it to crop future images
6. Segment the cropped ROI into 5 equal-width character arrays
7. Organize characters into labeled dataset using ground truth
8. Build character templates by averaging samples for each label
9. Recognize characters using template matching (NCC/MAE)
10. Evaluate performance using leave-one-captcha-out validation

## Current Status

All core modules are implemented and functional. The system achieves 0% accuracy in initial evaluation, indicating systematic issues that need investigation. Key findings:
- High confidence predictions but 100% error rate
- Systematic bias in character recognition
- Templates may have dimension or quality issues

## License

This project is developed for educational and research purposes.

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Ensure all tests pass
6. Submit a pull request